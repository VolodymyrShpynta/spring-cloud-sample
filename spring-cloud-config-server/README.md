### See articles:
- [Quick Intro to Spring Cloud Configuration](https://www.baeldung.com/spring-cloud-configuration)
- [Dockerizing a Spring Boot Application](https://www.baeldung.com/dockerizing-spring-boot-application)

We can retrieve the configuration for our planned config client running under development profile in branch master via: 
```
curl --header "Authorization: Basic cm9vdDpzM2NyM3Q=" http://localhost:8888/rest-producer/development/master
```
NOTE: 'cm9vdDpzM2NyM3Q' - it is Base64 encoded 'root:s3cr3t' (username and password)

#### Encryption and Decryption
**Requirement**: To use cryptographically strong keys together with Spring encryption and decryption features you need the ‘Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files’ installed in your JVM. These can be downloaded for example from [Oracle](https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html). To install follow the instructions included in the download. Some Linux distributions also provide an installable package through their package managers.

Since the config server is supporting encryption and decryption of property values, you can use public repositories as storage for sensitive data like usernames and passwords. Encrypted values are prefixed with the string {cipher} and can be generated by an REST-call to the path ‘/encrypt’, if the server is configured to use a symmetric key or a key pair.

An endpoint to decrypt is also available. Both endpoints accept a path containing placeholders for the name of the application and its current profile: ‘/*/{name}/{profile}’. This is especially useful for controlling cryptography per client. However, before they become useful, you have to configure a cryptographic key which we will do in the next section.

**Tip**: If you use curl to call the en-/decryption API, it’s better to use the –data-urlencode option (instead of –data/-d), or set the ‘Content-Type’ header explicit to ‘text/plain’. This ensures a correct handling of special characters like ‘+’ in the encrypted values.
For example:
```
curl --header "Authorization: Basic cm9vdDpzM2NyM3Q=" \
     --header "Content-Type: text/plain" \
     --request POST \
     --data 'pass123' \
     http://localhost:8888/encrypt
```

If a value can’t be decrypted automatically while fetching through the client, its key is renamed with the name itself, prefixed by the word ‘invalid’. This should prevent, for example the usage of an encrypted value as password.

**Tip**: When setting-up a repository containing YAML files, you have to surround your encrypted and prefixed values with single-quotes! With Properties this is not the case.

#### Key Management
The config server is per default enabled to encrypt property values in a symmetric or asymmetric way.

**To use symmetric cryptography**, you simply have to set the property ‘encrypt.key’ in your application.properties to a secret of your choice. Alternatively you can pass-in the environment variable ENCRYPT_KEY.

**For asymmetric cryptography**, you can set ‘encrypt.key’ to a PEM-encoded string value or configure a keystore to use.

Because we need a highly secured environment for our demo server, we chose the latter option and generating a new keystore, including a RSA key-pair, with the Java keytool first:

```
$> keytool -genkeypair -alias config-server-key \
       -keyalg RSA -keysize 4096 -sigalg SHA512withRSA \
       -dname 'CN=Config Server,OU=Spring Cloud,O=Baeldung' \
       -keypass my-k34-s3cr3t -keystore config-server.jks \
       -storepass my-s70r3-s3cr3t
```
After that, we’re adding the created keystore to our server’s bootstrap.yml and re-run it:

```
encrypt.key-store.location=classpath:/config-server.jks
encrypt.key-store.password=my-s70r3-s3cr3t
encrypt.key-store.alias=config-server-key
encrypt.key-store.secret=my-k34-s3cr3t
```
As next step we can query the encryption-endpoint and add the response as value to a configuration in our repository:

```
$> export PASSWORD=$(curl --header "Authorization: Basic cm9vdDpzM2NyM3Q=" \
                          --header "Content-Type: text/plain" \
                          --request POST \
                          --data 'pass123' \
                          http://localhost:8888/encrypt)
$> echo "user.password=$PASSWORD" >> rest-producer-development.properties
$> git commit -am 'Added encrypted password'
$> curl -X POST http://root:s3cr3t@localhost:8888/refresh
```
To test, if our setup works correctly, we’re modifying the GreetingControllerImpl class and restart our client:

```
@RestController
@Slf4j
public class GreetingControllerImpl implements GreetingController {

    ......

    @Value("${user.role}")
    private String role;

    @Value("${user.password}")
    private String password;

    @Value("${welcome.message}")
    private String welcomeMessage;

    @Override
    public String greeting(@PathVariable("username") String username) {
        simulateLongTermOperation();
        return format(welcomeMessage,
                username, role, password,
                eurekaClient.getApplication(appName).getName());
    }

    .....
}
```
A final query against our client will show us, if our configuration value is being correct decrypted:

```
$> curl http://localhost:8081/whoami/Mr_Pink
Hello! You're Mr_Pink and you'll become a(n) Developer, \
  but only if your password is 'd3v3L'!
```

#### Using Multiple Keys
If you want to use multiple keys for encryption and decryption, for example: a dedicated one for each served application, you can add another prefix in the form of {name:value} between the {cipher} prefix and the BASE64-encoded property value.

The config server understands prefixes like {secret:my-crypto-secret} or {key:my-key-alias} nearly out-of-the-box. The latter option needs a configured keystore in your application.properties. This keystore is searched for a matching key alias. For example:

```
user.password={cipher}{secret:my-499-s3cr3t}AgAMirj1DkQC0WjRv...
user.password={cipher}{key:rest-producer-key}AgAMirj1DkQC0WjRv...
```
For scenarios without keystore you have to implement a @Bean of type TextEncryptorLocator which handles the lookup and returns a TextEncryptor-Object for each key.

#### Serving Encrypted Properties
If you want to disable server-side cryptography and handle decryption of property-values locally, you can put the following in your server’s application.properties:

```
spring.cloud.config.server.encrypt.enabled=false
```
Furthermore you can delete all the other ‘encrypt.*’ properties to disable the REST endpoints.

### Run Config Server in Docker
Build Docker image:
```
docker build --file=Dockerfile \
     --tag=vshpynta/config-server:latest --rm=true .
```
Run Docker Image:
```
docker run --name=config-server --publish=8888:8888 \
     --env "EUREKA_URI=http://10.63.22.137:8761/eureka" \
     vshpynta/config-server:latest
```